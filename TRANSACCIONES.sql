USE RUEDALIBRE;

DROP PROCEDURE IF EXISTS PROYECTO.INSERTAR_TRY_CATCH;
GO
CREATE OR ALTER PROCEDURE PROYECTO.INSERTAR_TRY_CATCH
	@NOMBRE_PAIS VARCHAR(20),
	@DNI VARCHAR(20)
AS
BEGIN 
	DECLARE @MAX_ID INT;
	DECLARE @NUM_PACOS INT;
	SELECT @MAX_ID = (SELECT MAX(ID_PAIS) FROM PROYECTO.PAIS) + 1;
    
	BEGIN TRY
        BEGIN TRANSACTION;
		SET @NUM_PACOS = (SELECT COUNT(*) + 1 FROM PROYECTO.CLIENTE WHERE LEFT(NOMBRE,4) = 'Paco'); --seteo paco + número de paco que toca
		INSERT INTO PROYECTO.CLIENTE (NUM_IDENTIDAD,NOMBRE, APELLIDO1, TELEFONO, DIRECCION, LOCALIDAD, EMPRESA, PAIS_ID_PAIS)
        VALUES
		(@DNI, 'Paco' + CAST(@NUM_PACOS AS VARCHAR(5)), 'Clon', 600000000, 'Calle Perico de los palotes' + CAST(@NUM_PACOS AS VARCHAR(5)), 'Pacolandia', 0, 3);
		IF EXISTS (SELECT * FROM PROYECTO.PAIS WHERE LOWER(NOMBRE) = LOWER(@NOMBRE_PAIS)) --si meto un país que ya existe
			BEGIN
				PRINT ('Esto va a fallar');
				INSERT INTO PROYECTO.PAIS (ID_PAIS, NOMBRE) VALUES (@MAX_ID,NULL); --voy a hacer que falle
			END
		ELSE
			INSERT INTO PROYECTO.PAIS (ID_PAIS, NOMBRE) VALUES (@MAX_ID, @NOMBRE_PAIS); --si no me insertará el país que le diga al final
		COMMIT TRANSACTION;
        PRINT 'Transacción hecha.';
    END TRY
    BEGIN CATCH --bloque para controlar errores
        PRINT ('Hay un error en lo que insertas!');
        ROLLBACK TRANSACTION;
    END CATCH;
	-- UNION une todo sin repetir, UNION ALL repite, INTERSECT coge los comunes y EXCEPT coge A sin B, los tipos de variables deben coincidir en las columnas que se quieren ver (que deben ser mismo número)
	SELECT 'PAIS' AS TABLA, NOMBRE AS NOMBRE FROM PROYECTO.PAIS
	UNION ALL
	SELECT 'CLIENTE' AS TABLA, NOMBRE AS NOMBRE FROM PROYECTO.CLIENTE;
END;
GO

DROP PROCEDURE IF EXISTS PROYECTO.UPDATE_XACT;
GO
CREATE OR ALTER PROCEDURE PROYECTO.UPDATE_XACT
	@PAIS_ANTIGUO VARCHAR(20),
	@PAIS_NUEVO VARCHAR(20),
	@DNI VARCHAR(20)
AS
BEGIN
	DECLARE @NUM_PACOS INT;
	DECLARE @PAIS_ID INT;
	
	SET XACT_ABORT ON; -- si ocurre un error, la transacción se revierte automáticamente

	SET @NUM_PACOS = (SELECT COUNT(*) + 1 FROM PROYECTO.CLIENTE WHERE LEFT(NOMBRE,4) = 'Paco'); --seteo paco + número de paco que toca con set
	SELECT @PAIS_ID = ID_PAIS FROM PROYECTO.PAIS WHERE LOWER(NOMBRE) = LOWER(@PAIS_ANTIGUO); --esto lo seteo con un select
	 
	BEGIN TRANSACTION;

		INSERT INTO PROYECTO.CLIENTE (NUM_IDENTIDAD,NOMBRE, APELLIDO1, TELEFONO, DIRECCION, LOCALIDAD, EMPRESA, PAIS_ID_PAIS)
        VALUES
		(@DNI, 'Paco' + CAST(@NUM_PACOS AS VARCHAR(5)), 'Clon', 600000000, 'Calle Perico de los palotes' + CAST(@NUM_PACOS AS VARCHAR(5)), 'Pacolandia', 0, 3);

		IF @PAIS_ID IS NULL
				UPDATE PROYECTO.PAIS SET NOMBRE = NULL WHERE ID_PAIS = 1; --lo primero siempre va a funcionar, con esto anulo la primera inserción
		ELSE
			BEGIN
				UPDATE PROYECTO.PAIS SET NOMBRE = @PAIS_NUEVO WHERE ID_PAIS = @PAIS_ID;		 
				PRINT 'Actualización completada correctamente.';
			END;
	COMMIT TRANSACTION;
	-- Muestro los resultados
	SELECT 'PAIS' AS TABLA, NOMBRE AS NOMBRE FROM PROYECTO.PAIS
	UNION ALL
	SELECT 'CLIENTE' AS TABLA, NOMBRE AS NOMBRE FROM PROYECTO.CLIENTE;
END;
GO

SELECT * FROM PROYECTO.PAIS;
GO
SELECT * FROM PROYECTO.CLIENTE;
GO
EXECUTE PROYECTO.UPDATE_XACT 'Patatas', 'Carne', '85285285F';
GO
EXECUTE PROYECTO.INSERTAR_TRY_CATCH 'Espana', '22222222A';
GO
EXECUTE PROYECTO.BORRAR_CLIENTE '85285285F';
GO
DELETE FROM PROYECTO.PAIS WHERE ID_PAIS = 1;
GO